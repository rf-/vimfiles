" Enable true color
let $NVIM_TUI_ENABLE_TRUE_COLOR = 1

" Quickly open a Ruby REPL
nnoremap <Leader>e :bel 10split term://pry<CR>

" Run selection in a Ruby REPL
vnoremap <Leader>e y:bel 10split term://pry<CR><C-\><C-n>pi<CR>

""" Terminal-related config

" Bind <C-\><C-t> to open a new terminal split in normal and terminal modes
tnoremap <C-\><C-t> <C-\><C-n>:split<CR><C-\><C-n>:term<CR>
nnoremap <C-\><C-t> <C-\><C-n>:split<CR><C-\><C-n>:term<CR>

" Bind <C-\><C-\> to exit terminal
tnoremap <C-\><C-\> <C-\><C-n>

" Bind <C-\><C-k> to <C-k> for line editing
tnoremap <C-\><C-k> <C-k>

" Increase scrollback
let g:terminal_scrollback_buffer_size=100000

" Allow tab navigation directly from terminal
tnoremap <C-h> <C-\><C-n><C-w>h
tnoremap <C-j> <C-\><C-n><C-w>j
tnoremap <C-k> <C-\><C-n><C-w>k
tnoremap <C-l> <C-\><C-n><C-w>l

" On entering a terminal buffer, automatically focus
autocmd BufWinEnter,WinEnter term://* startinsert

" Fix meta bindings in terminal
for c in range(0, 25)
  let char=nr2char(c + char2nr("a"))
  exec "tnoremap <M-" . char . "> <Esc>" . char

  let char=nr2char(c + char2nr("A"))
  exec "tnoremap <M-" . char . "> <Esc>" . char
endfor

" In terminal buffers, make <Enter> automatically jump into insert mode
nnoremap <expr> <Enter> &buftype == 'terminal' ? 'i<CR>' : '<CR>'

""" FZF configuration

let g:fzf_command_prefix = 'Fzf'
let g:fzf_nvim_statusline = 0
let g:fzf_layout = { 'down': '~20' }
let g:fzf_action = {
  \ 'ctrl-t': 'tab split',
  \ 'ctrl-s': 'split',
  \ 'ctrl-v': 'vsplit' }

autocmd TermOpen *bin/fzf* setlocal statusline=\ 

function! s:fzf_set_color_options()
  if !exists('g:fzf_color_map')
    return
  endif
  let $FZF_DEFAULT_OPTS = '--color=' .
    \ join(values(map(copy(g:fzf_color_map), 'v:key . ":" . v:val')), ',')
endfunction

autocmd ColorScheme * call s:fzf_set_color_options()
call s:fzf_set_color_options()

let s:notes_dir = resolve(fnamemodify('~/.vim/notes/', ':p'))

function! s:fzf_notes_handler(lines)
  let query = a:lines[0]
  let key   = a:lines[1]
  let lines = len(a:lines) > 2 ? a:lines[2:] : [query]

  let filenames = map(lines,
    \ 'substitute(s:notes_dir . v:val . ".otl", " ", "\\\\ ", "g")')

  exec get(g:fzf_action, key, '')
  exec 'args ' . join(filenames, ' ')
endfunction

function! s:fzf_find_notes()
  let dir_len = strlen(s:notes_dir)
  let filenames = split(glob(s:notes_dir . '**/*.otl'), '\n')
  let notes = map(filenames,
    \ 'strpart(v:val, ' . dir_len . ', strlen(v:val) - ' . dir_len . ' - 4)')

  call fzf#run({
  \ 'source':  notes,
  \ 'sink*':   function('s:fzf_notes_handler'),
  \ 'options': '--multi --prompt "Notes> " --print-query ' .
  \            '--bind ctrl-a:select-all,ctrl-d:deselect-all ' .
  \            '--expect=' . join(keys(g:fzf_action), ','),
  \ 'down':    '~10',
  \})
endfunction

function! s:fzf_ag_to_qf(line)
  let parts = split(a:line, ':')
  return {'filename': parts[0], 'lnum': parts[1], 'col': parts[2],
        \ 'text': join(parts[3:], ':')}
endfunction

function! s:fzf_ag_handler(lines)
  if len(a:lines) < 2
    return
  endif

  let cmd = get(g:fzf_action, a:lines[0], 'e')
  let list = map(a:lines[1:], 's:fzf_ag_to_qf(v:val)')

  let first = list[0]
  execute cmd escape(first.filename, ' %#''"\')
  execute first.lnum
  execute 'normal!' first.col.'|zz'

  if len(list) > 1
    call setqflist(list)
    copen
    wincmd p
  endif
endfunction

function! s:fzf_ag(query)
  call fzf#run({
  \ 'source':  printf('ag --nogroup --column --color %s', a:query),
  \ 'sink*':   function('s:fzf_ag_handler'),
  \ 'options': '--ansi --delimiter : --nth 4..,.. --prompt "Ag> " ' .
  \            '--multi --bind ctrl-a:select-all,ctrl-d:deselect-all ' .
  \            '--expect=' . join(keys(g:fzf_action), ','),
  \ 'down':    '~20'
  \})
endfunction

command! FzfNotes
  \ call s:fzf_find_notes()
command! -bang -nargs=* -complete=dir
  \ Ag call s:fzf_ag(<q-args>)

function! s:get_registers()
  function! s:get_registers_inner()
    redir => output
    registers
    redir END
    return output
  endfunction

  silent let registers_output = s:get_registers_inner()
  let register_list = split(registers_output, "\n")[1:]
  let register_list = map(register_list, 'v:val[1:]')
  let uniq_register_list = []
  let seen_register_contents = {}

  for line in register_list
    if !get(seen_register_contents, line[1:], 0)
      let seen_register_contents[line[1:]] = 1
      call add(uniq_register_list, line)
    end
  endfor

  return uniq_register_list
endfunction

function! s:fzf_paste_handler(line)
  let register = a:line[0]
  exec 'normal "' . register . 'p'
endfunction

function! s:fzf_paste()
  let registers = s:get_registers()

  call fzf#run({
  \ 'source':  s:get_registers(),
  \ 'sink':    function('s:fzf_paste_handler'),
  \ 'options': '--ansi --prompt "Paste> " ',
  \ 'down':    '~20'
  \})
endfunction

command! FzfPaste call s:fzf_paste()

nnoremap <Leader>a "zyiw:exe "Ag ".@z.""<CR>
nnoremap <Leader>f :Ag<Space>
nnoremap <Leader>t :FzfBuffers<CR>
nnoremap <Leader>T :FzfFiles<CR>
nnoremap <Leader>` :FzfNotes<CR>
nnoremap <Leader>p :FzfPaste<CR>

" VimOutliner

function! s:votl_setup(filename)
  setlocal nowrap
  setlocal viewoptions=folds,cursor " only save folds and cursor pos
  silent! unmap <buffer> <C-k>

  let filename = resolve(fnamemodify(a:filename, ':p'))

  " If the file is inside the notes directory, clean up the statusline.
  if filename[:strlen(s:notes_dir) - 1] == s:notes_dir
    let filename = filename[strlen(s:notes_dir):]        " remove notes dir
    let filename = fnamemodify(filename, ':r')           " remove extension
    let filename = substitute(filename, ' ', '\\ ', 'g') " escape spaces

    exec 'setlocal statusline=[Note]\ ' . filename

    " Set view file location to also be inside the notes directory, so it gets
    " synced between computers.
    exec 'setlocal viewdir=' .  substitute(s:notes_dir, ' ', '\\ ', 'g') . '/.views'
    silent! loadview
  end

  augroup votlFolds
    autocmd! * <buffer>
    autocmd BufWinLeave <buffer> mkview
  augroup END
endfunction
autocmd FileType votl call s:votl_setup(@%)
