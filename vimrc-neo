" Enable true color and special cursor for insert mode
if $TERM_PROGRAM == "iTerm.app"
  set termguicolors
endif
set guicursor=i:ver1

" Quickly open Google
nnoremap <Leader>g :bel 30split term://links\ google.com<CR>

" Quickly open a Ruby REPL
nnoremap <Leader>e :bel 10split term://pry<CR>

" Run selection in a Ruby REPL
vnoremap <Leader>e y:bel 10split term://pry<CR><C-\><C-n>pi<CR>

" Enable deoplete; override enter behavior with popup open
let g:deoplete#enable_at_startup = 1
let g:deoplete#omni_patterns = {}
let g:deoplete#sources = {}
inoremap <silent> <CR> <C-r>=<SID>close_popup_and_insert_cr()<CR>
function! s:close_popup_and_insert_cr() abort
  return deoplete#close_popup() . "\<CR>"
endfunction

" Enable deoplete support for Reason
let g:deoplete#omni_patterns.reason = '[^. *\t]\.\w*\|\h\w*|#'
let g:deoplete#sources.reason = ['omni', 'buffer']

" Enable deoplete support for Rust
let g:deoplete#sources#rust#racer_binary = $HOME . '/.cargo/bin/racer'
let g:deoplete#sources#rust#rust_source_path = $HOME . '/src/vendor/rust/src'

""" Terminal-related config

" Fix meta bindings in terminal
for c in range(0, 25)
  let char=nr2char(c + char2nr("a"))
  exec "tnoremap <M-" . char . "> <Esc>" . char

  let char=nr2char(c + char2nr("A"))
  exec "tnoremap <M-" . char . "> <Esc>" . char
endfor

" Bind <C-\><C-[> and <C-\><C-]> to switch tabs in all modes
tnoremap <C-\><C-[> <C-\><C-n>gT
tnoremap <C-\><C-]> <C-\><C-n>gt
nnoremap <C-\><C-[> gT
nnoremap <C-\><C-]> gt
vnoremap <C-\><C-[> gT
vnoremap <C-\><C-]> gt
inoremap <C-\><C-[> <C-o>gT
inoremap <C-\><C-]> <C-o>gt

" Bind <C-\><C-t> to open a new terminal split in normal and terminal modes
tnoremap <C-\><C-t> <C-\><C-n>:split<CR><C-\><C-n>:term<CR>
nnoremap <C-\><C-t> <C-\><C-n>:split<CR><C-\><C-n>:term<CR>

" Bind <C-\><C-\> to exit terminal
tnoremap <C-\><C-\> <C-\><C-n>

" Bind <M-k> to <C-k> for line editing
tnoremap <M-k> <C-k>

" Increase scrollback
let g:terminal_scrollback_buffer_size=100000

" Allow split navigation directly from terminal
tnoremap <C-h> <C-\><C-n><C-w>h
tnoremap <C-j> <C-\><C-n><C-w>j
tnoremap <C-k> <C-\><C-n><C-w>k
tnoremap <C-l> <C-\><C-n><C-w>l

" On entering a terminal buffer, automatically enter insert mode unless we're
" scrolled up
function! s:start_insert_if_at_bottom()
  if (line('w$') >= line('$'))
    startinsert
  endif
endfunction
autocmd TermOpen,BufWinEnter,WinEnter term://* call s:start_insert_if_at_bottom()

" When opening a term, disable line numbers; when leaving one, enable them
autocmd TermOpen,BufWinEnter term://* setlocal nonumber
autocmd BufWinLeave term://* setlocal number

" In terminal buffers, make <Enter> automatically jump into insert mode
nnoremap <expr> <Enter> &buftype == 'terminal' ? 'i<CR>' : '<CR>'

""" FZF configuration

let g:fzf_command_prefix = 'Fzf'
let g:fzf_nvim_statusline = 0
let g:fzf_layout = { 'down': '~20' }
let g:fzf_action = {
  \ 'ctrl-t': 'tab split',
  \ 'ctrl-s': 'split',
  \ 'ctrl-v': 'vsplit',
  \ 'ctrl-e': 'pedit'
  \ }

nnoremap <C-e> :pclose<CR>

autocmd! FileType fzf
autocmd FileType fzf set laststatus=0 | autocmd BufLeave <buffer> set laststatus=2

function! s:fzf_set_color_options()
  if !exists('g:fzf_color_map')
    return
  endif
  let $FZF_DEFAULT_OPTS = '--color=' .
    \ join(values(map(copy(g:fzf_color_map), 'v:key . ":" . v:val')), ',')
endfunction

autocmd ColorScheme * call s:fzf_set_color_options()
call s:fzf_set_color_options()

nnoremap <Leader>t :FzfBuffers<CR>
nnoremap <Leader>T :FzfFiles<CR>

nnoremap <silent> <C-]> :call search("\\k")<CR>"zyiw:call custom_fzf_funcs#tags(@z, '1')<CR>
vnoremap <silent> <C-]> "zy:call custom_fzf_funcs#tags(@z, '1')<CR>
nnoremap <silent> g<C-]> :call search("\\k")<CR>"zyiw:call custom_fzf_funcs#tags(@z, '0')<CR>
vnoremap <silent> g<C-]> "zy:call custom_fzf_funcs#tags(@z, '0')<CR>

" Load and bind custom FZF functions
exec "source " . g:vimfiles_dir . "/lib/custom_fzf_funcs.vim"

command! -bang -nargs=* -complete=dir Ag call custom_fzf_funcs#ag(<q-args>)

nnoremap <Leader>a "zyiw:exe "Ag ".@z.""<CR>
nnoremap <Leader>f :Ag<Space>
nnoremap <Leader>` :call custom_fzf_funcs#wiki()<CR>
nnoremap <Leader>p :call custom_fzf_funcs#paste()<CR>

" gutentags

let g:gutentags_define_advanced_commands = 1
let g:gutentags_project_info = []
call add(g:gutentags_project_info, { "type": "crystal", "file": "shard.yml" })

" See https://gist.github.com/rf-/2b74152aae77a147a0dd1b7f102ea2ee
let g:gutentags_ctags_executable_crystal = "crystal-tags"

" ale

let g:ale_lint_on_text_changed = 'never'

" Flow utils

autocmd FileType javascript nnoremap <buffer> <silent> <C-p> :call FlowType()<CR>
